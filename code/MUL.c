#include "MUL.h"

void AB(word* A, word* B, word* C0, word* C1) {
	word A0, A1, B0, B1, T, T0, T1, x;
	x = sizeof(word) * 4;// w/2
	A1 = *A >> x;
	A0 = *A - (A1 << x);
	B1 = *B >> x;
	B0 = *B - (B1 << x);
	// A B 상위 하위 w/2비트씩 쪼개기
	T0 = A0 * B1;
	T1 = A1 * B0;

	T0 += T1;
	T1 = T0 < T1;
	//T0에 값을 더하고 T1은 carry가 생기는지 여부
	*C0 = A0 * B0;
	*C1 = A1 * B1;
	T = *C0;
	//C0에는 T0의 하위 w/2비트만 더하고, C1에는 T0의 상위 w/2비트와 carry를 더함
	*C0 += (T0 << x);
	*C1 += (T1 << x) + (T0 >> x) + (*C0 < T);
}

void MULC(bigint* A, bigint* B, bigint** C) {
	word i, j;
	// AB연산을 받아줄 T 생성
	bigint* T = NULL;
	//T와 C의 크기를 나올 수 있는 최대치로 만들기
	bi_new(C, A->wordlen + B->wordlen);
	bi_new(&T, A->wordlen + B->wordlen);
	if (T != NULL) {
		for (i = 0; i < A->wordlen; i++)
			for (j = 0; j < B->wordlen; j++)
			{
				//워드 단위로 곱셈 가짓수를 전부 실행
				AB(&A->a[i], &B->a[j], &T->a[i + j], &T->a[i + j + 1]);
				//C와 덧셈
				ADDC(*C, T, C);
				//다음 값을 온전히 받기 위해 T를 0으로
				T->a[i + j] = 0;
				T->a[i + j + 1] = 0;
			}
		//T를 다 썼으니 삭제
		bi_delete(T);
	}
	//각 부호에 따라 C의 부호 결정 
	(*C)->sign = (A->sign) ^ (B->sign);
}

